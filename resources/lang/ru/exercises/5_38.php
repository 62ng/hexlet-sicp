<?php

return [
    'title' => "Явное кодирование отдельных примитивов",
    'description' => [
        '1' =>
        "Наш компилятор тщательно избегает ненужных операций со стеком, но с точки зрения перевода вызовов элементарных процедур языка в операции машины он очень слаб. " .
        "Рассмотрим, например, сколько кода порождается для вычисления ",
        '2' =>
        ": код порождает список аргументов в ",
        '3' =>
        ", помещает элементарную процедуру сложения (которую он находит через поиск символа ",
        '4' =>
        " в окружении) в ",
        '5' =>
        ", затем проверяет, является ли эта процедура элементарной или составной. Компилятор всегда порождает код этой проверки, а также код для ветви элементарной процедуры и ветви составной процедуры (из которых только одна будет выполняться). " .
        "Мы не показали ту часть контроллера, которая реализует примитивы, но мы предполагаем, что эти команды используют элементарные арифметические операции в путях данных машины. " .
        "Рассмотрим, насколько меньше кода будет порождаться, если компилятор сможет вставлять примитивы в виде явного кода (open coding) — то есть порождать код, который прямо использует эти машинные операции. Выражение ",
        '6' =>
        " можно было бы скомпилировать в простую последовательность вроде",
        '7' =>
        "В этом упражнении мы расширим компилятор так, чтобы он поддерживал явное кодирование отдельных примитивов. При обращениях к этим примитивам будет порождаться специально написанный код, а не общий код для вызова процедуры. " .
        "Для того, чтобы поддержать такую работу, мы дополним машину специальными регистрами для аргументов ",
        '8' =>
        " и ",
        '9' =>
        ". Элементарные арифметические операции машины будут принимать свои аргументы в ",
        '10' =>
        " и ",
        '11' =>
        ". Они могут помещать результаты в ",
        '12' =>
        ", ",
        '13' =>
        " или ",
        '14' =>
        ".",
        '15' =>
        "Компилятор должен уметь распознавать вызов явно кодируемого примитива в исходной программе. Мы дополним распознаватель в процедуре ",
        '16' =>
        ", так, чтобы он узнавал имена этих примитивов в дополнение к зарезервированным словам (особым формам), которые он узнает сейчас. " .
        "Для каждой особой формы в компиляторе есть свой генератор кода. В этом упражнении мы построим семью генераторов кода для явно кодируемых примитивов.",
        '17' =>
        "а. В отличие от особых форм, явно кодируемые примитивы требуют, чтобы их аргументы вычислялись. Напишите генератор кода ",
        '18' =>
        ", который будут использовать генераторы явного кода. ",
        '19' =>
        " должен принимать список операндов и компилировать данные ему операнды, направляя их в последовательные аргументные регистры. Заметим, что операнд может содержать вызов явно кодируемого примитива, так что во время вычисления операндов придется сохранять аргументные регистры.",
        '20' =>
        "б. Для каждой из элементарных процедур ",
        '21' =>
        ", ",
        '22' =>
        ", ",
        '23' =>
        " и ",
        '24' =>
        " напишите по генератору кода, который принимает комбинацию, содержащую этот оператор вместе с целевым регистром и описателем связи, и порождает код, который раскидывает аргументы по регистрам, а затем проводит операцию с данным целевым регистром и указанным типом связи. " .
        "Достаточно обрабатывать только выражения с двумя операндами. Заставьте ",
        '25' =>
        " передавать управление этим генераторам кода.",
        '26' =>
        "в. Опробуйте обновленный компилятор на примере с процедурой ",
        '27' =>
        ". Сравните полученный результат с результатом, который получается без открытого кодирования.",
        '28' =>
        "г. Расширьте свои генераторы кода для ",
        '29' =>
        " и ",
        '30' =>
        " так, чтобы они могли обрабатывать выражения с произвольным числом операндов. Выражение, в котором операндов больше двух, придется компилировать в последовательность операций, каждая из которых работает с двумя входами.",
    ],
];
